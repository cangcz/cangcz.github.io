<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/06/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="写完新的博客后"><a href="#写完新的博客后" class="headerlink" title="写完新的博客后"></a>写完新的博客后</h3><p>先g一下，再d一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>怎么都过不了</title>
    <url>/2022/06/06/difficult/</url>
    <content><![CDATA[<h1 id="codeup"><a href="#codeup" class="headerlink" title="codeup"></a>codeup</h1><h2 id="To-Fill-or-Not-to-Fill"><a href="#To-Fill-or-Not-to-Fill" class="headerlink" title="To Fill or Not to Fill"></a>To Fill or Not to Fill</h2><blockquote>
<p>健健一直想不出来，我想了个和参考不太一样的方法，初始化每个加油站的start和end，遍历每个加油站可到达的加油站，比较价格，修改start和end。</p>
</blockquote>
<p>只过了pat</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//codeup To Fill or Not to Fill</span></span><br><span class="line"><span class="comment">//汽油容量 距离 每个gas可跑距离 汽油站数量</span></span><br><span class="line"><span class="comment">//59	  525	 19				2</span></span><br><span class="line"><span class="comment">//单价	   距离</span></span><br><span class="line"><span class="comment">//3			314</span></span><br><span class="line"><span class="comment">//3			 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">station</span> &#123;</span><br><span class="line">	<span class="type">double</span> price;</span><br><span class="line">	<span class="type">double</span> start;</span><br><span class="line">	<span class="type">double</span> end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(station a, station b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> max, meter, per_meter, n;</span><br><span class="line">	station sta[<span class="number">510</span>];</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; max &gt;&gt; meter &gt;&gt; per_meter &gt;&gt; n) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			cin &gt;&gt; sta[i].price &gt;&gt; sta[i].start;</span><br><span class="line">			sta[i].end = sta[i].start + max * per_meter;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">sort</span>(sta, sta + n, cmp);</span><br><span class="line">		<span class="comment">/*for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; &quot;排序结果\n&quot;;</span></span><br><span class="line"><span class="comment">			cout &lt;&lt; sta[i].start &lt;&lt; &quot;  &quot; &lt;&lt; sta[i].end &lt;&lt; &quot; &quot;&lt;&lt;sta[i].price&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">		&#125;*/</span></span><br><span class="line">		<span class="keyword">if</span> (sta[<span class="number">0</span>].start != <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;The maximum travel distance = &quot;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="number">0.00</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sta[i].end &gt; meter) &#123;</span><br><span class="line">				sta[i].end = meter;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (sta[j].start &lt; sta[i].end) &#123;</span><br><span class="line">					<span class="keyword">if</span> (sta[j].price &lt;= sta[i].price) &#123;<span class="comment">//新的更便宜</span></span><br><span class="line">						<span class="keyword">if</span>(sta[i].start&gt;sta[j].start &amp;&amp;sta[i].end&lt;sta[j].end)&#123;<span class="comment">//被包围</span></span><br><span class="line">							sta[i].end = sta[i].start;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						sta[i].end = sta[j].start;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						sta[j].start = sta[i].end;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;<span class="comment">//没有加油站了</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">double</span> money = <span class="number">0</span>, all_meter = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="comment">//cout &lt;&lt; sta[i].start &lt;&lt; &quot;  &quot; &lt;&lt; sta[i].end &lt;&lt; endl;</span></span><br><span class="line">			all_meter += sta[i].end - sta[i].start;</span><br><span class="line">			money += (sta[i].end - sta[i].start) / per_meter * sta[i].price;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (all_meter &lt; meter) &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;The maximum travel distance = &quot;</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, all_meter);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, money);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="【递归入门】出栈序列统计"><a href="#【递归入门】出栈序列统计" class="headerlink" title="【递归入门】出栈序列统计"></a>【递归入门】出栈序列统计</h2><p>是一道深度优先的递归题，抄了答案，对递归还是不太明白。<br>[8.1小节递归入门E]: <a class="link"   href="http://codeup.hustoj.com/problem.php?cid=100000608&amp;pid=4" >http://codeup.hustoj.com/problem.php?cid=100000608&amp;pid=4<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> in, <span class="type">int</span> out)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (out &gt; n) &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (in &gt; n || out &gt; in) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">f</span>(in + <span class="number">1</span>, out);</span><br><span class="line">		<span class="built_in">f</span>(in, out + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">		cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">f</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>随机数</title>
    <url>/2022/06/20/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h1 id="普通随机数"><a href="#普通随机数" class="headerlink" title="普通随机数"></a>普通随机数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rand</span>()</span><br></pre></td></tr></table></figure>

<h1 id="0-b-a"><a href="#0-b-a" class="headerlink" title="[0,b-a]"></a>[0,b-a]</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rand</span>()%(b-a+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="a-b"><a href="#a-b" class="headerlink" title="[a,b]"></a>[a,b]</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rand</span>()%(b-a+<span class="number">1</span>)+a</span><br></pre></td></tr></table></figure>

<h1 id="大整数"><a href="#大整数" class="headerlink" title="大整数"></a>大整数</h1><p>rand生成的随机数不能大于RAND_MAX（stdlib.h中的一个常数，不同系统的值不同，这里int取32767），当要生成的[a,b]，b大于RAND_MAX的数时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="type">int</span>)(<span class="built_in">round</span>(<span class="number">1.0</span>*<span class="built_in">rand</span>()/RAND_MAX*(b-a)+a))</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>小记</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度</title>
    <url>/2022/06/20/%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">最坏</th>
<th align="center">平均</th>
</tr>
</thead>
<tbody><tr>
<td align="center">快排</td>
<td align="center">O(n^2)</td>
<td align="center">O(nlogn)</td>
</tr>
<tr>
<td align="center">随机选择算法</td>
<td align="center">O(n^2)</td>
<td align="center">O(N)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="素数"><a href="#素数" class="headerlink" title="素数"></a>素数</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[2,sqrt(n)]</td>
<td align="center">O(sqrt(n))</td>
</tr>
<tr>
<td align="center">埃氏筛法</td>
<td align="center">O(nloglogn)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">substr()</td>
<td align="center">O(len)</td>
</tr>
<tr>
<td align="center">find()</td>
<td align="center">O(nm)</td>
</tr>
</tbody></table>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Dijkstra （邻接矩阵）</td>
<td align="center">O(V^2) ，V:点</td>
</tr>
<tr>
<td align="center">Dijkstra (邻接表)</td>
<td align="center">O(V^2+E)</td>
</tr>
<tr>
<td align="center">Bellman-Ford</td>
<td align="center">O(VE)</td>
</tr>
<tr>
<td align="center">SPFA</td>
<td align="center">O(kE)</td>
</tr>
<tr>
<td align="center">Floyd</td>
<td align="center">O(n^3)</td>
</tr>
<tr>
<td align="center">prim</td>
<td align="center">O(V^2)</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PaddleClas图像分类</title>
    <url>/2022/07/01/PaddleClas%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文将讲解利用PaddleCals实现对图像进行分类的任务，利用AI Studio平台训练，并通过猫十二分类例子讲解如何进行训练与预测。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>PaddlePaddle 2.1.2</li>
<li>PaddleClas 2.3</li>
</ul>
<h2 id="下载PaddleClas"><a href="#下载PaddleClas" class="headerlink" title="下载PaddleClas"></a>下载PaddleClas</h2><p>此时可以将PaddleClas下载到项目中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!git clone https://gitee.com/paddlepaddle/PaddleClas/ --depth=1</span><br></pre></td></tr></table></figure>

<h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><h4 id="1-解压数据集"><a href="#1-解压数据集" class="headerlink" title="1.解压数据集"></a>1.解压数据集</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解压缩数据集</span><br><span class="line">!unzip -qoa data/data8136/cat_data_sets_models.zip -d data/</span><br></pre></td></tr></table></figure>
<h4 id="2-划分数据集"><a href="#2-划分数据集" class="headerlink" title="2.划分数据集"></a>2.划分数据集</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def break_data(target, rate=0.2):</span><br><span class="line">    origin_dataset = pd.read_csv(&quot;/home/aistudio/data/data_sets/cat_12/train_list.txt&quot;, delimiter=&quot;\t&quot;, header=None)  # 加入参数</span><br><span class="line">    # train_data, test_data = train_test_split(origin_dataset, test_size=rate)</span><br><span class="line">    train_data,eval_data=train_test_split(origin_dataset, test_size=rate)</span><br><span class="line">    train_filename = os.path.join(target, &#x27;train.txt&#x27;)</span><br><span class="line">    # test_filename = os.path.join(target, &#x27;test.txt&#x27;)</span><br><span class="line">    eval_filename = os.path.join(target, &#x27;eval.txt&#x27;)</span><br><span class="line"></span><br><span class="line">    train_data.to_csv(train_filename, index=False, sep=&quot;\t&quot;, header=None)</span><br><span class="line">    # test_data.to_csv(test_filename, index=False, sep=&quot;\t&quot;, header=None)</span><br><span class="line">    eval_data.to_csv(eval_filename, index=False, sep=&quot;\t&quot;, header=None)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    break_data(target=&#x27;data&#x27;, rate=0.2)</span><br></pre></td></tr></table></figure>
<h4 id="3-通道转化"><a href="#3-通道转化" class="headerlink" title="3.通道转化"></a>3.通道转化</h4><p>由于图片中存在一些非RGB格式的图片，会影响训练，因此进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#导入需要的包</span><br><span class="line">import os</span><br><span class="line">import random</span><br><span class="line">import json</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line">from PIL import Image</span><br><span class="line">import paddle</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">## 转换4通道为3通道</span><br><span class="line">def proc_img(src):</span><br><span class="line">    for root, dirs, files in os.walk(src):</span><br><span class="line">        if &#x27;__MACOSX&#x27; in root:continue</span><br><span class="line">        for file in files:            </span><br><span class="line">            src=os.path.join(root,file)</span><br><span class="line">            img=Image.open(src)</span><br><span class="line">            ## 转换4通道为3通道</span><br><span class="line">            if img.mode != &#x27;RGB&#x27;: </span><br><span class="line">                    img = img.convert(&#x27;RGB&#x27;) </span><br><span class="line">                    img.save(src)    </span><br><span class="line">                    print(src)        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    proc_img(&quot;data/data_sets/cat_12/cat_12_train&quot;)</span><br><span class="line">    proc_img(&quot;data/data_sets/cat_12/cat_12_test&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h4 id="1-修改bug"><a href="#1-修改bug" class="headerlink" title="1.修改bug"></a>1.修改bug</h4><p>由于PaddleClas2.3版本读数据存在bug，因此修改如下文件<br>目录：\ppcls\data\dataloader\imagenet_dataset.py<br>注释:</p>
<ul>
<li><code>assert os.path.exists(self._cls_path)</code></li>
<li><code>assert os.path.exists(self._img_path)</code><br>添加：</li>
<li><code>self._cls_path=os.path.join(self._img_root,self._cls_path)</code><br>同时修改with open（）as fd:中的内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ImageNetDataset(CommonDataset):</span><br><span class="line">    def _load_anno(self, seed=None):</span><br><span class="line">        # 会对目录进行检测，如果cls_path使用相对目录，就会报错，在此注释掉，并修改为self._cls_path=os.path.join(self._img_root,self._cls_path)</span><br><span class="line"></span><br><span class="line">        self.images = []</span><br><span class="line">        self.labels = []</span><br><span class="line"></span><br><span class="line">        with open(self._cls_path) as fd:</span><br><span class="line">            lines = fd.readlines()</span><br><span class="line">            if seed is not None:</span><br><span class="line">                np.random.RandomState(seed).shuffle(lines)</span><br><span class="line">            for l in lines:</span><br><span class="line">            	  # tab分割</span><br><span class="line">                # l = l.strip().split(&quot; &quot;)</span><br><span class="line">                l = l.strip().split(&quot;\t&quot;)</span><br><span class="line">                self.images.append(os.path.join(self._img_root, l[0]))</span><br><span class="line">                self.labels.append(int(l[1]))</span><br><span class="line">                # 不需要判断这个</span><br><span class="line">                # assert os.path.exists(self.images[-1])</span><br></pre></td></tr></table></figure>
<h4 id="2-修改配置文件"><a href="#2-修改配置文件" class="headerlink" title="2.修改配置文件"></a>2.修改配置文件</h4>选择PaddleClas&#x2F;ppcls&#x2F;configs&#x2F;ImageNet&#x2F; 中的模型，这里以ResNet为例，选择其中的<code>ResNet50_vd.yaml</code>配置文件，主要修改参数如下：</li>
<li>class_num: 12<br>Train和Eval下均需修改</li>
<li>image_root: &#x2F;home&#x2F;aistudio&#x2F;data&#x2F;data_sets&#x2F;cat_12&#x2F;</li>
<li>cls_label_path: &#x2F;home&#x2F;aistudio&#x2F;data&#x2F;eval.txt</li>
</ul>
<h4 id="3-配置说明"><a href="#3-配置说明" class="headerlink" title="3.配置说明"></a>3.配置说明</h4><h6 id="3-1-全局配置-Global"><a href="#3-1-全局配置-Global" class="headerlink" title="3.1 全局配置(Global)"></a>3.1 全局配置(Global)</h6><table>
<thead>
<tr>
<th align="center">参数名字</th>
<th align="center">具体含义</th>
<th align="center">默认值</th>
<th align="center">可选值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">checkpoints</td>
<td align="center">断点模型路径，用于恢复训练</td>
<td align="center">null</td>
<td align="center">str</td>
</tr>
<tr>
<td align="center">pretrained_model</td>
<td align="center">预训练模型路径</td>
<td align="center">null</td>
<td align="center">str</td>
</tr>
<tr>
<td align="center">output_dir</td>
<td align="center">保存模型路径</td>
<td align="center">“.&#x2F;output&#x2F;“</td>
<td align="center">str</td>
</tr>
<tr>
<td align="center">save_interval</td>
<td align="center">每隔多少个epoch保存模型</td>
<td align="center">1</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">eval_during_train</td>
<td align="center">是否在训练时进行评估</td>
<td align="center">True</td>
<td align="center">bool</td>
</tr>
<tr>
<td align="center">eval_interval</td>
<td align="center">每隔多少个epoch进行模型评估</td>
<td align="center">1</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">epochs</td>
<td align="center">训练总epoch数</td>
<td align="center"></td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">print_batch_step</td>
<td align="center">每隔多少个mini-batch打印输出</td>
<td align="center">10</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">use_visualdl</td>
<td align="center">是否是用visualdl可视化训练过程</td>
<td align="center">False</td>
<td align="center">bool</td>
</tr>
<tr>
<td align="center">image_shape</td>
<td align="center">图片大小</td>
<td align="center">[3，224，224]</td>
<td align="center">list, shape: (3,)</td>
</tr>
<tr>
<td align="center">save_inference_dir</td>
<td align="center">inference模型的保存路径</td>
<td align="center">“.&#x2F;inference”</td>
<td align="center">str</td>
</tr>
<tr>
<td align="center">eval_mode</td>
<td align="center">eval的模式</td>
<td align="center">“classification”</td>
<td align="center">“retrieval”</td>
</tr>
</tbody></table>
<h6 id="3-2-结构-Arch"><a href="#3-2-结构-Arch" class="headerlink" title="3.2 结构(Arch)"></a>3.2 结构(Arch)</h6><table>
<thead>
<tr>
<th align="center">参数名字</th>
<th align="center">具体含义</th>
<th align="center">默认值</th>
<th align="center">可选值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">模型结构名字</td>
<td align="center">ResNet50</td>
<td align="center">PaddleClas提供的模型结构</td>
</tr>
<tr>
<td align="center">class_num</td>
<td align="center">分类数</td>
<td align="center">1000</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">pretrained</td>
<td align="center">预训练模型</td>
<td align="center">False</td>
<td align="center">bool， str</td>
</tr>
</tbody></table>
<h6 id="3-3-损失函数（Loss）"><a href="#3-3-损失函数（Loss）" class="headerlink" title="3.3 损失函数（Loss）"></a>3.3 损失函数（Loss）</h6><table>
<thead>
<tr>
<th align="center">参数名字</th>
<th align="center">具体含义</th>
<th align="center">默认值</th>
<th align="center">可选值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CELoss</td>
<td align="center">交叉熵损失函数</td>
<td align="center">——</td>
<td align="center">——</td>
</tr>
<tr>
<td align="center">CELoss.weight</td>
<td align="center">CELoss的在整个Loss中的权重</td>
<td align="center">1.0</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">CELoss.epsilon</td>
<td align="center">CELoss中label_smooth的epsilon值</td>
<td align="center">0.1</td>
<td align="center">float，0-1之间</td>
</tr>
</tbody></table>
<h6 id="3-4-优化器-Optimizer"><a href="#3-4-优化器-Optimizer" class="headerlink" title="3.4 优化器(Optimizer)"></a>3.4 优化器(Optimizer)</h6><table>
<thead>
<tr>
<th align="center">参数名字</th>
<th align="center">具体含义</th>
<th align="center">默认值</th>
<th align="center">可选值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">优化器方法名</td>
<td align="center">“Momentum”</td>
<td align="center">“RmsProp”等其他优化器</td>
</tr>
<tr>
<td align="center">momentum</td>
<td align="center">momentum值</td>
<td align="center">0.9</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">lr.name</td>
<td align="center">学习率下降方式</td>
<td align="center">“Cosine”</td>
<td align="center">“Linear”、”Piecewise”等其他下降方式</td>
</tr>
<tr>
<td align="center">lr.learning_rate</td>
<td align="center">学习率初始值</td>
<td align="center">0.1</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">lr.warmup_epoch</td>
<td align="center">warmup轮数</td>
<td align="center">0</td>
<td align="center">int，如5</td>
</tr>
<tr>
<td align="center">regularizer.name</td>
<td align="center">正则化方法名</td>
<td align="center">“L2”</td>
<td align="center">[“L1”, “L2”]</td>
</tr>
<tr>
<td align="center">regularizer.coeff</td>
<td align="center">正则化系数</td>
<td align="center">0.00007</td>
<td align="center">float</td>
</tr>
</tbody></table>
<h4 id="4-开始训练"><a href="#4-开始训练" class="headerlink" title="4.开始训练"></a>4.开始训练</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用以下命令进入项目目录</span><br><span class="line">%cd PaddleClas/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GPU设置</span><br><span class="line">!export CUDA_VISIBLE_DEVICES=0</span><br><span class="line"></span><br><span class="line"># -o Arch.pretrained=True 使用预训练模型，当选择为True时，预训练权重会自动下载到本地</span><br><span class="line">!python tools/train.py -c /home/aistudio/PaddleClas/ppcls/configs/ImageNet/ResNet/ResNet50_vd.yaml -o Arch.pretrained=True</span><br></pre></td></tr></table></figure>

<p>使用多卡训练</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!export CUDA_VISIBLE_DEVICES=0,1,2,3</span><br><span class="line">!python3 -m paddle.distributed.launch \</span><br><span class="line">    --gpus=&quot;0,1,2,3&quot; \</span><br><span class="line">    tools/train.py \</span><br><span class="line">        -c /home/aistudio/ResNet50_vd.yaml -o Arch.pretrained=True</span><br></pre></td></tr></table></figure>

<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>输入以下命令进行单张图片预测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 预测</span><br><span class="line">!python3 tools/infer.py -c /home/aistudio/ResNet50_vd.yaml -o Infer.infer_imgs=/home/aistudio/data/data_sets/cat_12/cat_12_test/ou9Ik17GtHSThRCDLZm3f6vB8ybQ4xsl.jpg  -o Global.pretrained_model=output/ResNet50_vd/best_model</span><br></pre></td></tr></table></figure>
<p>输入以下命令进行批量图片预测，并重定向到output.txt文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 预测</span><br><span class="line">!python3 tools/infer.py -c /home/aistudio/ResNet50_vd.yaml -o Infer.infer_imgs=/home/aistudio/data/data_sets/cat_12/cat_12_test/  -o Global.pretrained_model=output/ResNet50_vd/best_model &gt; output.txt</span><br></pre></td></tr></table></figure>
<p>输入以下命令生成提交的csv文件格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import ast</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">with open(&quot;output.txt&quot;) as f:</span><br><span class="line">    ftxt = f.read()</span><br><span class="line">    </span><br><span class="line">pattern = r&quot;&#123;&#x27;class_ids&#x27;:.*?&#125;&quot;</span><br><span class="line">pre_results = re.findall(pattern, ftxt)</span><br><span class="line">print(len(pre_results))</span><br><span class="line"></span><br><span class="line">pre_data = []</span><br><span class="line">for pre_result in pre_results:</span><br><span class="line">    pre_dict = ast.literal_eval(pre_result)  # [&quot;class_ids&quot;, &quot;scores&quot;, &quot;file_name&quot;, &quot;label_names&quot;]</span><br><span class="line">    pre_data.append([pre_dict[&quot;file_name&quot;].split(&quot;/&quot;)[-1],\</span><br><span class="line">                            pre_dict[&quot;class_ids&quot;][0], pre_dict[&quot;scores&quot;][0]])</span><br><span class="line"></span><br><span class="line">columns = [&quot;img_path&quot;, &quot;label&quot;, &quot;scores&quot;]</span><br><span class="line">pre_df = pd.DataFrame(data=pre_data,</span><br><span class="line">                       index=range(len(pre_data)), </span><br><span class="line">                       columns=columns)</span><br><span class="line"></span><br><span class="line">pre_df.drop(columns=[&#x27;scores&#x27;],inplace=True)  # 删除 scores 列</span><br><span class="line">pre_df.sort_values([&quot;img_path&quot;], inplace=True)  # 排序</span><br><span class="line">pre_df.to_csv(&#x27;submission.csv&#x27;,index=None,header=None)</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>Paddle</tag>
      </tags>
  </entry>
  <entry>
    <title>需要注意的点</title>
    <url>/2022/06/06/%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<p>刷题时经常不会直接AC，部分错误又很令人头疼，以下是部分踩过的坑，希望可以铭记于心。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><h4 id="补位"><a href="#补位" class="headerlink" title="补位"></a>补位</h4><p>需要注意题目的输出格式,可能不会直说，若是00001时，注意要在高位补0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%05d&quot;</span>,a);<span class="comment">//以0补充</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5d&quot;</span>,a);<span class="comment">//以5位右对齐输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.5f&quot;</span>,b);<span class="comment">//保留五位小数</span></span><br></pre></td></tr></table></figure>



<h4 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h4><p>用cout输出大数会产生科学计数法</p>
<p> iomanip——定义IO流输出输入格式的头文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">0</span>) &lt;&lt; 数据 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//不以科学计数法输出—固定格式+0精度</span></span><br></pre></td></tr></table></figure>

<h3 id="取余"><a href="#取余" class="headerlink" title="取余"></a>取余</h3><p>要求对结果的大数取模时，若最后再取模，可能在计算过程中越界，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">	a+=b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a%<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>存在公式<br>$$<br>(a\pm b)%p&#x3D;(a%p\pm b%p)%p\<br>(a<em>b)%m&#x3D;(a%m</em>b%m)%m\<br>a^b%m&#x3D;(a%m)^b%m<br>$$<br>因此，可以在循环中取模</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">	a=(a+b)%<span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>

<h3 id="时间超限"><a href="#时间超限" class="headerlink" title="时间超限"></a>时间超限</h3><ul>
<li><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4></li>
</ul>
<p> 利用<strong>cout</strong>和<strong>cin</strong>在数据量大时会直接超时，需使用**printf()<strong>和</strong>scanf()**。</p>
<ol>
<li><h5 id="char数组"><a href="#char数组" class="headerlink" title="char数组"></a>char数组</h5></li>
</ol>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5></li>
</ol>
<p>   只能用cin和cout进行输入输出，可利用<code>c_str()</code>转换为char数组。</p>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">cout&lt;&lt;s;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s.<span class="built_in">c_str</span>())</span><br></pre></td></tr></table></figure>

<h3 id="double精度问题"><a href="#double精度问题" class="headerlink" title="double精度问题"></a>double精度问题</h3><p>double可能会导致误差，如double*int和int*double计算所得答案不同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1104 Sum of Number Segments</span></span><br><span class="line"><span class="type">double</span> ans=<span class="number">0</span>,temp;</span><br><span class="line">ans += temp * (i + <span class="number">1</span>) * (N - i);</span><br><span class="line">ans +=  (i + <span class="number">1</span>) * (N - i) * temp;</span><br><span class="line"><span class="comment">//两者计算答案不同</span></span><br></pre></td></tr></table></figure>

<p>可以利用long long 型，对浮点数先乘1000后除1000的方法避免误差（ 假设测试样例的小数在三位以内，四五六位经过多次累加进位后依然可能会引起精度问题）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">ans += (<span class="type">long</span> <span class="type">long</span>)(a * <span class="number">1000</span> * (N - i) * (i + <span class="number">1</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans / <span class="number">1000.0</span>);</span><br></pre></td></tr></table></figure>

<p>1106 Lowest Price in Supply Chain中，需计算叶子节点的深度，利用复利法计算结果</p>
<p>若递归时，参数设为double，会导致错误点二错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> rate;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> root,<span class="type">double</span> price)</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    <span class="built_in">DFS</span>(newroot, (<span class="number">1</span>+rate) * price);</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若递归时，参数设置为int记录层数，最后再计算,成功AC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> layer)</span> </span>&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="built_in">DFS</span>(newroot, layer + <span class="number">1</span>);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> price = <span class="built_in">pow</span>((<span class="number">1</span> + r), minlayer)  * P;</span><br></pre></td></tr></table></figure>

<h3 id="cmath"><a href="#cmath" class="headerlink" title="cmath"></a>cmath</h3><p>引入<code>#include&lt;cmath&gt;</code></p>
<p>以e为底：<code>log(exp(n))</code></p>
<p>以10为底：<code>log10(n)</code></p>
<p>以m为底：<code>log(n)/log(m)</code></p>
<h3 id="map和哈希表"><a href="#map和哈希表" class="headerlink" title="map和哈希表"></a>map和哈希表</h3><p>​	将学生名字abc9(由三个字母和一个数字组成）对应到表中，利用<code>map&lt;string,int&gt;</code>可能导致存储过大，提示段错误，因此可考虑hash表的形式。</p>
<ul>
<li><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4>map中元素自动按键从小到大排序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt;clas;</span><br><span class="line">clas[<span class="string">&quot;abc9&quot;</span>]=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>可通过map.count()函数判断某键是否存在。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clas.<span class="built_in">count</span>(<span class="string">&quot;abc9&quot;</span>);<span class="comment">//1</span></span><br><span class="line">clas.<span class="built_in">count</span>(<span class="string">&quot;aaa8&quot;</span>);<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将字母和数字利用ASCII表映射到数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hash</span><span class="params">(<span class="type">char</span> name[<span class="number">5</span>])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        num=num*<span class="number">26</span>+name[i]-<span class="string">&#x27;A&#x27;</span>;<span class="comment">//注意*26和减&#x27;A&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    num=num*<span class="number">10</span>+name[<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//注意*10和减&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转变后姓名对应着索引，可知索引最大是26*26*26*10，创建数组或vector时需注意大小。</p>
<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><p>当结点的地址是比较小的整数（如5位数的地址）时，可采用静态链表，相比动态链表更加方便。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="type">int</span> next;</span><br><span class="line">&#125;node[size];</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">node[<span class="number">00011</span>].data = data;</span><br><span class="line">node[<span class="number">00011</span>].next = next;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>类型转换</title>
    <url>/2022/07/03/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><ul>
<li><h5 id="char"><a href="#char" class="headerlink" title="char"></a>char</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string a;</span><br><span class="line"><span class="type">char</span> n[<span class="number">10</span>]=a.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="int"><a href="#int" class="headerlink" title="int"></a>int</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string a;</span><br><span class="line"><span class="type">int</span> n=<span class="built_in">atoi</span>(a.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="double"><a href="#double" class="headerlink" title="double"></a>double</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string a;</span><br><span class="line"><span class="type">double</span> n=<span class="built_in">atof</span>(a.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="char-1"><a href="#char-1" class="headerlink" title="char"></a>char</h4><ul>
<li><h5 id="int-1"><a href="#int-1" class="headerlink" title="int"></a>int</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="string">&#x27;3&#x27;</span> - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误做法：</span></span><br><span class="line"><span class="type">char</span> c = <span class="number">1</span>;</span><br><span class="line">a = (<span class="type">int</span>)c;</span><br><span class="line">cout &lt;&lt; a;<span class="comment">//49</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<h4 id="int-2"><a href="#int-2" class="headerlink" title="int"></a>int</h4><ul>
<li><h5 id="char-2"><a href="#char-2" class="headerlink" title="char"></a>char</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">1</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//不可以用char c = char(1)</span></span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>stack实现简单计算器</title>
    <url>/2022/07/09/stack%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8-%E5%89%8D%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80/</url>
    <content><![CDATA[<h1 id="stack实现简单计算器"><a href="#stack实现简单计算器" class="headerlink" title="stack实现简单计算器"></a>stack实现简单计算器</h1><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>通过一个 index 值（索引），遍历表达式</p>
</li>
<li><p>如果发现是一个<strong>数字</strong>, 就<strong>直接入数栈</strong>。</p>
</li>
<li><p>如果发现扫描到是一个<strong>符号</strong>,  就分如下情况：</p>
<ol>
<li><p>如果当前的<strong>符号栈为空</strong>，就直接入栈。</p>
</li>
<li><p>如果符号栈有操作符，就进行比较,如果当前的操作符的优先级<strong>小于或者等于栈中的操作符</strong>， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈。</p>
<p>再<strong>与新的符号栈顶进行比较</strong>，直到不再小于或等于栈顶操作符，将当前的操作符入符号栈。</p>
</li>
<li><p>如果当前的操作符的优先级<strong>大于栈中的操作符</strong>， 就直接入符号栈。</p>
</li>
</ol>
</li>
<li><p>当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行。</p>
</li>
<li><p>最后在数栈只有一个数字，就是表达式的结果。</p>
</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><a class="link"   href="http://codeup.hustoj.com/contest.php?cid=100000602" >Codeup简易计算器<i class="fas fa-external-link-alt"></i></a> </p>
<p>代码写了很久，因为网上的教程在3.2步时：比较新操作符与栈顶的优先级，若小于或等于栈顶，则pop出两个数，pop出一个符号进行计算，随后将新符压入符号栈，并没有继续比较新的栈顶。对于公式1-2*3+4*5；当所有字符都被压入栈后，符号栈为-、*，数字栈为1、6、20，最后计算时：6*20&#x3D;120，1-120&#x3D;-119。</p>
<p>另外，弹出数字后，应注意是a-b，还是b-a。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//stack codeup 问题 A: 简单计算器</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cal</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b, <span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; b + a &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> b + a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; b - a &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> b - a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; b / a &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> b / a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; b * a &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> b * a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//char s[200];</span></span><br><span class="line">	string s;</span><br><span class="line">	map&lt;<span class="type">char</span>, <span class="type">double</span>&gt; op;</span><br><span class="line">	op[<span class="string">&#x27;+&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">	op[<span class="string">&#x27;-&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">	op[<span class="string">&#x27;*&#x27;</span>] = <span class="number">1</span>;<span class="comment">//优先级更高</span></span><br><span class="line">	op[<span class="string">&#x27;/&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin, s)) &#123;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;size&quot; &lt;&lt; s.size() &lt;&lt; endl;</span></span><br><span class="line">		stack &lt;<span class="type">char</span>&gt;oper;</span><br><span class="line">		stack &lt;<span class="type">double</span>&gt;num;</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; s;</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>();) &#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!(s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;<span class="comment">//符号</span></span><br><span class="line">				<span class="keyword">if</span> (oper.<span class="built_in">empty</span>() == <span class="literal">true</span>) &#123;<span class="comment">//如果符号栈空，则直接入栈</span></span><br><span class="line">					<span class="type">char</span> n = s[i];</span><br><span class="line">					oper.<span class="built_in">push</span>(n);</span><br><span class="line">					<span class="comment">//cout &lt;&lt; &quot;符号入栈&quot; &lt;&lt; oper.top() &lt;&lt; endl;</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;<span class="comment">//符号栈非空，与top进行优先级比较</span></span><br><span class="line">					<span class="keyword">if</span> (op[s[i]] &lt;= op[oper.<span class="built_in">top</span>()]) &#123;<span class="comment">//出两个数字和一个操作符进行计算</span></span><br><span class="line">						<span class="keyword">while</span> (oper.<span class="built_in">size</span>() &gt;= <span class="number">1</span> &amp;&amp; op[s[i]] &lt;= op[oper.<span class="built_in">top</span>()]) &#123;<span class="comment">//继续比较</span></span><br><span class="line">							<span class="type">double</span> a = num.<span class="built_in">top</span>();<span class="comment">//数字出栈</span></span><br><span class="line">							num.<span class="built_in">pop</span>();</span><br><span class="line">							<span class="comment">//cout &lt;&lt; &quot;数字出栈&quot; &lt;&lt; a &lt;&lt; &quot; &quot;;</span></span><br><span class="line">							<span class="type">double</span> b = num.<span class="built_in">top</span>();</span><br><span class="line">							num.<span class="built_in">pop</span>();</span><br><span class="line">							<span class="comment">//cout &lt;&lt; &quot;数字出栈&quot; &lt;&lt; b &lt;&lt; &quot; &quot;;</span></span><br><span class="line">							<span class="type">char</span> t;<span class="comment">//符号出栈</span></span><br><span class="line">							t = oper.<span class="built_in">top</span>();</span><br><span class="line">							oper.<span class="built_in">pop</span>();</span><br><span class="line">							<span class="comment">//cout &lt;&lt; &quot;符号出栈&quot; &lt;&lt; t &lt;&lt; &quot; &quot;;</span></span><br><span class="line">							<span class="type">double</span> ans = <span class="built_in">cal</span>(a, b, t);</span><br><span class="line">							num.<span class="built_in">push</span>(ans);</span><br><span class="line">						&#125;</span><br><span class="line">						oper.<span class="built_in">push</span>(s[i]);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;<span class="comment">//新运算符优先级高，直接入栈</span></span><br><span class="line">						oper.<span class="built_in">push</span>(s[i]);</span><br><span class="line">						<span class="comment">//cout &lt;&lt; &quot;符号入栈&quot; &lt;&lt; oper.top();</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="comment">//数字</span></span><br><span class="line">				<span class="type">int</span> temp = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">				i++;</span><br><span class="line">				<span class="keyword">while</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">					temp = temp * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//cout &lt;&lt; &quot;数字入栈&quot; &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">				num.<span class="built_in">push</span>(temp);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//double ans = num.top();</span></span><br><span class="line">		<span class="comment">//cout &lt;&lt; ans &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">while</span> (num.<span class="built_in">size</span>() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="type">double</span> a = num.<span class="built_in">top</span>();</span><br><span class="line">			num.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">double</span> b = num.<span class="built_in">top</span>();</span><br><span class="line">			num.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">char</span> t = oper.<span class="built_in">top</span>();</span><br><span class="line">			oper.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="type">double</span> ans = <span class="built_in">cal</span>(a, b, t);</span><br><span class="line">			num.<span class="built_in">push</span>(ans);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, num.<span class="built_in">top</span>(), <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h1><p><code> 1+((2+3)* 4)-5</code> 转换为<code>123+4*+5–</code> </p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>遍历中缀表达式。</li>
<li>当读到<strong>数字</strong>时，立即把它输出，即成为后缀表达式的一部分。</li>
<li>若读到操作符，判断该符号与栈顶符号的优先级：<ol>
<li>若该符号优先级<strong>高于栈顶元素</strong>，则将该操作符入栈。</li>
<li>否则就一次把栈中运算符弹出并加到后缀表达式尾端，直到遇到优先级低于该操作符的栈元素，然后把该操作符压入栈中。</li>
<li>如果遇到<strong>”(”</strong>，直接压入栈中，如果遇到一个<strong>”)”</strong>，那么就将栈元素弹出并加到后缀表达式尾端，但左右括号并不输出。</li>
</ol>
</li>
<li>最后，如果读到中缀表达式的尾端，将栈元素<strong>依次完全弹出</strong>并加到后缀表达式尾端。</li>
</ol>
<h1 id="中缀转前缀"><a href="#中缀转前缀" class="headerlink" title="中缀转前缀"></a>中缀转前缀</h1><p><code>1+((2+3)*4)–5</code>转为<code>\-+1*+2345</code></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li><strong>从右至左</strong>遍历中缀表达式。</li>
<li>如果是<strong>数字</strong>，直接输出，作为前缀表达式的一个直接转换表达式Temp（最后，前缀表达式由该表达式翻转得到）；</li>
<li>如果是<strong>运算符</strong>，则比较优先级：<ol>
<li>若该运算符优先级<strong>大于等于栈顶元素</strong>，则将该运算符<strong>入栈</strong>。</li>
<li>否则栈内元素出栈并加到Temp表达式尾端，<strong>直到该运算符大于等于栈顶元素</strong>的优先级时，再将该运算符压入栈中。</li>
<li>遇到<strong>右括号</strong>直接压入栈中，如果遇到一个<strong>左括号</strong>，那么就将栈元素弹出并加到Temp表达式尾端，但左右括号并不输出。</li>
</ol>
</li>
<li>最后，若运算符栈中还有元素，则将元素<strong>一次弹出</strong>并加到Temp表达式尾端，最后一步是将Temp表达式<strong>翻转</strong>。</li>
</ol>
<h1 id="前缀转中缀"><a href="#前缀转中缀" class="headerlink" title="前缀转中缀"></a>前缀转中缀</h1><p><code>-+1*+2345</code>转为<code>5-(1+(2+3)*4)</code></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>只有数字栈</p>
<ol>
<li><strong>从右到左</strong>扫描前缀表达式</li>
<li>如果遇到<strong>数字</strong>，则入栈。</li>
<li>如果遇到<strong>操作符</strong>，则将栈顶个元素弹出，并和操作符结合写成表达式，作为中缀表达式。</li>
<li>如果遇到的操作符优先级大于已存在表达式的最后执行操作符的优先级，则将已存在的表达式加上（）。</li>
</ol>
<hr>
<p>参考 <a class="link"   href="https://blog.csdn.net/walkerkalr/article/details/22798365" > 前缀、中缀、后缀表达式转换详解<i class="fas fa-external-link-alt"></i></a> </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2022/08/07/String/</url>
    <content><![CDATA[<h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><ul>
<li><p>1001、1005、1035、1061、1073、1077、1082、1093、1108、1140、1152</p>
</li>
<li><p>回文：1019、1024、1136</p>
</li>
</ul>
<h4 id="比大小"><a href="#比大小" class="headerlink" title="比大小"></a>比大小</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以直接进行比较</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">cout&lt;&lt;S;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s.<span class="built_in">c_str</span>());<span class="comment">//将string转换为字符数组</span></span><br></pre></td></tr></table></figure>

<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string::iterator it;</span><br></pre></td></tr></table></figure>

<h4 id="插入insert"><a href="#插入insert" class="headerlink" title="插入insert()"></a>插入insert()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">insert</span>(pos,string);</span><br><span class="line"><span class="built_in">insert</span>(it,it2,it3);<span class="comment">//串[it2,it3)将被插在it的位置上 it、it2、it3是迭代器，如s.begin()+2</span></span><br></pre></td></tr></table></figure>

<h4 id="删除erase"><a href="#删除erase" class="headerlink" title="删除erase()"></a>删除erase()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">erase</span>(it);</span><br><span class="line">s.<span class="built_in">erase</span>(first,last);<span class="comment">//删除[first,last)区间（迭代器表示）</span></span><br><span class="line">s.<span class="built_in">erase</span>(pos,length);<span class="comment">//pos:起始下标，length：长度</span></span><br></pre></td></tr></table></figure>

<h4 id="清空clear"><a href="#清空clear" class="headerlink" title="清空clear()"></a>清空clear()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<h4 id="截取substr"><a href="#截取substr" class="headerlink" title="截取substr()"></a>截取substr()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>(pos,len);<span class="comment">//从下标pos开始，长度为len的子串，复杂度为O(len)</span></span><br></pre></td></tr></table></figure>

<h4 id="查找find"><a href="#查找find" class="headerlink" title="查找find()"></a>查找find()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复杂度为O(nm)</span></span><br><span class="line">s.<span class="built_in">find</span>(s2);<span class="comment">//返回说第一次出现的位置，否则，返回string::npos(-1)</span></span><br><span class="line">s.<span class="built_in">find</span>(s2,pos);<span class="comment">//从pos开始找</span></span><br></pre></td></tr></table></figure>

<h4 id="替代replace"><a href="#替代replace" class="headerlink" title="替代replace()"></a>替代replace()</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">replace</span>(pos,len,s2);<span class="comment">//把s从pos开始，长度为len的子串替换为s2</span></span><br><span class="line">s.<span class="built_in">replace</span>(it1,it2,str2);<span class="comment">//迭代器[it1,it2)范围的子串替换为s2</span></span><br></pre></td></tr></table></figure>



<p> <strong>1136 A Delayed Palindrome</strong> </p>
<ol>
<li><h5 id="char-to-int"><a href="#char-to-int" class="headerlink" title="char to int"></a>char to int</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="string">&#x27;3&#x27;</span> - <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="int-to-char"><a href="#int-to-char" class="headerlink" title="int to char"></a>int to char</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="number">1</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="comment">//不可以用char c = char(1)</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2022/08/09/%E6%A0%91/</url>
    <content><![CDATA[<h5 id="题目：🍔"><a href="#题目：🍔" class="headerlink" title="题目：🍔"></a>题目：🍔</h5><p>1094 25 The Largest Generation					树 DFS or BFS<br>1053 30 Path of Equal Weight			     		树 DFS 路径和，并且记录路径<br>1079 25 Total Sales of Supply Chain	  		树 DFS 叶子节点求和<br>1090 25 Highest Price in Supply Chain  		树 DFS 深度最大<br>1106 25 Lowest Price in Supply Chain   		树 DFS 深度最小<br>1004 30 Counting Leaves			 					树 BFS 每层有几个叶子节点<br>1086 25 Tree Traversals Again   		      		二叉树 顺序转变 先序+中序&#x3D;&gt;后序<br>1102 25 Invert a Binary Tree     			  		 二叉树 输出层序、中序<br>1020 25 Tree Traversals									二叉树 后序+中序&#x3D;&gt;层序  懒得重新做<br>1043 25 Is It a Binary Search Tree     	 		 BST二叉搜索树 建树、各种顺序输出<br>1064 30 Complete Binary Search Tree ☆ 	  BST二叉搜索树+CBT完全二叉树 中序转CBT、层序输出<br>1099 30 Build A Binary Search Tree     		   BST二叉搜索树 已知树的结构和序列，层序输出<br>1066 25 Root of AVL Tree						     	AVL树 插入操作 第一次写不是很熟<br>1107 30 Social Clusters									并查集 基础操作 第一次写不是很熟<br>1098 25 Insertion or Heap Sort					  堆 基础操作 第一次写不是很熟</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="静态写法构造树"><a href="#静态写法构造树" class="headerlink" title="静态写法构造树"></a>静态写法构造树</h3><ol>
<li><p><strong>结点没有数据，可能有多个孩子，利用vector数组记录，将结点的孩子push_back进父节点的数组中。</strong></p>
<p>🎈1094 The Largest Generation</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; Node[MAXN];</span><br><span class="line">Node[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);<span class="comment">//2是1的孩子</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>结点有数据，并且树的结点按照下标构成，可以考虑开创一个数组来记录数据</strong></p>
</li>
</ol>
<p>   🎈1079 Total Sales of Supply Chain</p>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; chain[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> project[<span class="number">100010</span>];</span><br><span class="line">project[<span class="number">1</span>] = <span class="number">10</span>;<span class="comment">//1号结点的数据是10</span></span><br><span class="line">chain[<span class="number">1</span>].<span class="built_in">push_back</span>(<span class="number">2</span>);<span class="comment">//2是1的孩子</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><strong>结点有数据，可能有多个孩子，构造结构体</strong></p>
<p>🎈1053 Path of Equal Weight</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; child;<span class="comment">//储存孩子在tree中的索引</span></span><br><span class="line">&#125;;</span><br><span class="line">node tree[<span class="number">110</span>];</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="树的宽度优先"><a href="#树的宽度优先" class="headerlink" title="树的宽度优先"></a>树的宽度优先</h3><p>利用队列</p>
<p>🎈1004 Counting Leaves</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BFS</span></span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		……</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; top.child.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			……</span><br><span class="line">			q.<span class="built_in">push</span>(tree[top.child[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	node* lchild = <span class="literal">NULL</span>;</span><br><span class="line">	node* rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">root -&gt; data = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="遍历转换"><a href="#遍历转换" class="headerlink" title="遍历转换"></a>遍历转换</h3><p><strong>中序序列可与先序序列、后序序列、层序序列中的任意一个来构造唯一的二叉树</strong></p>
<h5 id="先序-中序-x3D-gt-后序"><a href="#先序-中序-x3D-gt-后序" class="headerlink" title="先序+中序&#x3D;&gt;后序"></a>先序+中序&#x3D;&gt;后序</h5><p>🎈1086 Tree Traversals Again</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、得到先序pre[maxn]和中序in[maxn]数组；</span></span><br><span class="line"><span class="type">int</span> pre[maxn],in[maxn];</span><br><span class="line">……</span><br><span class="line"><span class="comment">//2、构造后序</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> inL, <span class="type">int</span> inR)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//若函数参数表达范围是[preL,preR]、[inL,inR]，递归结束条件为if (preL &gt; preR)</span></span><br><span class="line">	<span class="keyword">if</span> (preL + <span class="number">1</span> &gt; preR) &#123;<span class="comment">//函数参数表达范围是[preL,preR)、[inL,inR)</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">	<span class="type">int</span> i = inL;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; inR; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre[preL] == in[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    root-&gt;lchild = <span class="built_in">create</span>(preL + <span class="number">1</span>, preL + i - inL + <span class="number">1</span>, inL, i);</span><br><span class="line">	root-&gt;rchild = <span class="built_in">create</span>(preL + i - inL + <span class="number">1</span>, preR, i + <span class="number">1</span>, inR);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉查找树BST"><a href="#二叉查找树BST" class="headerlink" title="二叉查找树BST"></a>二叉查找树BST</h2><ul>
<li><strong>对BST进行中序遍历，遍历的结果是有序的。</strong></li>
</ul>
<h2 id="完全二叉树CBT"><a href="#完全二叉树CBT" class="headerlink" title="完全二叉树CBT"></a>完全二叉树CBT</h2><ul>
<li><p>满二叉树：每一层都是满的</p>
<p>完全二叉树：除最后一层都是满的</p>
</li>
<li><p>使用<strong>数组</strong>存放，则对于任何一个结点（设编号为n，<strong>根节点编号为1</strong>），其左孩子的下标为<strong>2n</strong>，右孩子为<strong>2n+1</strong>。</p>
</li>
<li><p>CBT数组本身就是层序遍历</p>
</li>
</ul>
<ol>
<li><p><strong>输入一串序列，可以得到唯一一颗完全二叉查找树</strong></p>
<p>🎈1064 Complete Binary Search Tree </p>
<p>题解：</p>
<ol>
<li>对输入序列排序，排序后的数组，就是二叉查找树的中序遍历结果。</li>
<li>根据中序和完全二叉树下标性质，得到CBT数组。</li>
<li>CBT数组本身就是层序遍历，输出。</li>
</ol>
<p>已知中序遍历，求完全二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N, num[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cbt[<span class="number">1010</span>], index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root &gt; N) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inorder</span>(root * <span class="number">2</span>);</span><br><span class="line">	cbt[root] = num[index++];</span><br><span class="line">	<span class="built_in">inorder</span>(root * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(num, num + N, cmp);</span><br><span class="line">	<span class="comment">//num是结果的中序遍历</span></span><br><span class="line">	<span class="built_in">inorder</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cout &lt;&lt; cbt[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cbt[N] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="AVL平衡二叉树"><a href="#AVL平衡二叉树" class="headerlink" title="AVL平衡二叉树"></a>AVL平衡二叉树</h2><h3 id="结点定义"><a href="#结点定义" class="headerlink" title="结点定义"></a><strong>结点定义</strong></h3><p>需记录高度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> v, height = <span class="number">1</span>;</span><br><span class="line">	node* left = <span class="literal">NULL</span>, right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a><strong>插入操作</strong></h3><p>:heart:注意：左旋、右旋、插入的参数是<code>node* &amp;root</code>，加引用是因为会对root进行修改，需要记录最新的根节点。</p>
<p>共六个函数：得到高度、更新高度、计算平衡因子、右旋、左旋、插入。</p>
<table>
<thead>
<tr>
<th align="center">树形</th>
<th align="center">平衡因子</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LL &#x2F;</td>
<td align="center">root&#x3D;2,root-&gt;left&#x3D;1</td>
<td align="center">root右旋</td>
</tr>
<tr>
<td align="center">LR &lt;</td>
<td align="center">root&#x3D;2,root-&gt;left&#x3D;-1</td>
<td align="center">root-&gt;left左旋，root右旋</td>
</tr>
<tr>
<td align="center">RR \</td>
<td align="center">root&#x3D;-2,root-&gt;right&#x3D;-1</td>
<td align="center">root左旋</td>
</tr>
<tr>
<td align="center">RL &gt;</td>
<td align="center">root&#x3D;-2,root-&gt;right&#x3D;1</td>
<td align="center">root-&gt;right右旋，root左旋</td>
</tr>
</tbody></table>
<ol>
<li><h5 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h5><p><strong>得到</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//注意root为空的情况</span></span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	root-&gt;height = <span class="built_in">max</span>(<span class="built_in">getgetHeight</span>(root-&gt;left), <span class="built_in">getgetHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">balance</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">getHeight</span>(root-&gt;left) - <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;left;</span><br><span class="line">	root-&gt;left = temp-&gt;right;</span><br><span class="line">	temp-&gt;right = root;</span><br><span class="line">	<span class="built_in">update</span>(root);</span><br><span class="line">	<span class="built_in">update</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">L</span><span class="params">(node*&amp; root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;right;</span><br><span class="line">	root-&gt;right = temp-&gt;left;</span><br><span class="line">	temp-&gt;left = root;</span><br><span class="line">	<span class="built_in">update</span>(root);</span><br><span class="line">	<span class="built_in">update</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node*&amp; root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">		root-&gt;data = num;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; root-&gt;data) &#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;left, num);</span><br><span class="line">		<span class="built_in">update</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">balance</span>(root) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">balance</span>(root-&gt;left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">R</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">L</span>(root-&gt;left);</span><br><span class="line">				<span class="built_in">R</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;right, num);</span><br><span class="line">		<span class="built_in">update</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">balance</span>(root) &lt;= <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">balance</span>(root-&gt;right) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">R</span>(root-&gt;right);</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">node* root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    cin &gt;&gt; temp;</span><br><span class="line">    <span class="built_in">insert</span>(root, temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> father[N];</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		f[i] = i;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找-压缩"><a href="#查找-压缩" class="headerlink" title="查找+压缩"></a>查找+压缩</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfather</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> z = x;</span><br><span class="line">	<span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">		x = f[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//此时x是根节点</span></span><br><span class="line">	<span class="keyword">while</span>(f[z] != x)&#123;</span><br><span class="line">		<span class="type">int</span> t = f[z];</span><br><span class="line">		f[z] = x;</span><br><span class="line">		z = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> fa = <span class="built_in">findfather</span>(a);</span><br><span class="line">	<span class="type">int</span> fb = <span class="built_in">findfather</span>(b);</span><br><span class="line">	<span class="keyword">if</span>(fa != fb)&#123;</span><br><span class="line">		f[fa]=  fb;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul>
<li><p>属于完全二叉树，**利用数组存放[1,N]**。</p>
<p>非叶子结点：**[1,N&#x2F;2]**💕</p>
<p>对于结点N，孩子结点为<strong>2N</strong>、<strong>2N+1</strong>，父节点为<strong>N&#x2F;2</strong></p>
<p><code>int num[maxn];</code></p>
</li>
</ul>
<h3 id="向下调整"><a href="#向下调整" class="headerlink" title="向下调整"></a>向下调整</h3><p>用于建堆、堆排序、删除数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在[low,heigh]范围内调整，low为欲调整结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> heigh)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> child = low * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (child &lt;= heigh) &#123; <span class="comment">//有孩子</span></span><br><span class="line">		<span class="keyword">if</span> (child + <span class="number">1</span> &lt;= heigh &amp;&amp; num[child] &lt; num[child + <span class="number">1</span>]) &#123;<span class="comment">//有右孩子，且右孩子更大</span></span><br><span class="line">			child++;<span class="comment">//指向右孩子</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (iter[low] &lt; iter[child]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(iter[low], iter[child]);</span><br><span class="line">			low = child;</span><br><span class="line">			child = low * <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//该结点调整结束</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>下文以大顶堆为例，若最后想得到升（降）序序列，需先构造大（小）顶堆。</p>
<p>从<strong>最后非一个叶子结点N&#x2F;2</strong>开始，向下调整，将更大的值往上放</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">create</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = N / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)&#123;<span class="comment">//从最后非一个叶子结点倒着进行</span></span><br><span class="line">        <span class="built_in">downAdjust</span>(i, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>在大顶堆的基础上</p>
<ol>
<li>交换根节点和最后一个未确定的结点<code>swap(N[1],N[heigh])</code></li>
<li>在[1,heigh-1]的范围内向下调整，1为欲调整结点</li>
<li>不断重复1、2</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">create</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = N; i &gt; <span class="number">1</span>; i --)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(num[<span class="number">1</span>], num[i]);</span><br><span class="line">        <span class="built_in">downAdjust</span>(<span class="number">1</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除堆顶"><a href="#删除堆顶" class="headerlink" title="删除堆顶"></a>删除堆顶</h3><p>num[1,N]是一个大顶堆</p>
<ol>
<li>交换最后一个元素和堆顶</li>
<li>堆长度-1</li>
<li>对新堆顶进行向下调整</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(num[<span class="number">1</span>],num[N]);</span><br><span class="line">    N--;</span><br><span class="line">    <span class="built_in">downAdjust</span>(<span class="number">1</span>, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向上调整"><a href="#向上调整" class="headerlink" title="向上调整"></a>向上调整</h3><p>用于插入</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">upAdjust</span><span class="params">(<span class="type">int</span> low,<span class="type">int</span> heigh)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> father = heigh / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span>(heigh &gt;= low)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[heigh] &gt; num[father])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(num[heigh], num[father]);</span><br><span class="line">            heigh = father;</span><br><span class="line">            father = heigh / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>插入于最后一个位置，再进行向上调整</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	num[++N] = x;</span><br><span class="line">	<span class="built_in">upAdjust</span>(<span class="number">1</span>, N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>recursively ：递归地</p>
<p>traversal ：遍历;穿越;追踪;周游;树的遍历</p>
<p>sequence ： 序列; 顺序;  按顺序排列;  </p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h3 id="1094-The-Largest-Generation-BFS-or-DFS"><a href="#1094-The-Largest-Generation-BFS-or-DFS" class="headerlink" title="1094 The Largest Generation BFS or DFS"></a>1094 The Largest Generation BFS or DFS</h3><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data,layer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> N, M;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; family[<span class="number">110</span>];</span><br><span class="line">	<span class="type">int</span> ID, K, child;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++ ) &#123;</span><br><span class="line">		cin &gt;&gt; ID &gt;&gt; K;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; K; j++) &#123;</span><br><span class="line">			cin &gt;&gt; child;</span><br><span class="line">			family[ID].<span class="built_in">push_back</span>(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	queue&lt;node*&gt;q;</span><br><span class="line">	node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">	root-&gt;layer = <span class="number">1</span>;</span><br><span class="line">	root-&gt;data = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="type">int</span> num[<span class="number">110</span>];</span><br><span class="line">	<span class="built_in">fill</span>(num, num + <span class="number">110</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node* top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		num[top-&gt;layer]++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; family[top-&gt;data].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			node* temp = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">			temp-&gt;data = family[top-&gt;data][i];</span><br><span class="line">			temp-&gt;layer = top-&gt;layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> max = <span class="number">1</span>, maxlay = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] &gt; num[maxlay]) &#123;</span><br><span class="line">			maxlay = i;</span><br><span class="line">			max = num[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxlay &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; family[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> layer[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">	layer[height]++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; family[root].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="built_in">DFS</span>(family[root][i], height + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> N, M;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="type">int</span> ID, n, child;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">		cin &gt;&gt; ID &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">			cin &gt;&gt; child;</span><br><span class="line">			family[ID].<span class="built_in">push_back</span>(child);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">fill</span>(layer, layer + <span class="number">110</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> max = <span class="number">1</span>, maxlayer = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (layer[i] &gt; maxlayer) &#123;</span><br><span class="line">			maxlayer = layer[i];</span><br><span class="line">			max = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; maxlayer &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; max &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1053-Path-of-Equal-Weight"><a href="#1053-Path-of-Equal-Weight" class="headerlink" title="1053 Path of Equal Weight"></a>1053 Path of Equal Weight</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line">node tree[<span class="number">110</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;temp;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;ans;</span><br><span class="line"><span class="type">int</span> n, m, w;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> weight)</span> </span>&#123;</span><br><span class="line">	node root = tree[index];</span><br><span class="line">	weight += root.data;</span><br><span class="line">	<span class="keyword">if</span> (tree[index].child.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; weight == w) &#123;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (weight &gt;= w) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; tree[index].child.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="type">int</span> id = tree[index].child[i];</span><br><span class="line">		temp.<span class="built_in">push_back</span>(tree[id].data);</span><br><span class="line">		<span class="built_in">dfs</span>(id, weight);</span><br><span class="line">		temp.<span class="built_in">pop_back</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a,vector&lt;<span class="type">int</span>&gt; b )</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; a.<span class="built_in">size</span>() &amp;&amp; i &lt; b.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; b[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &lt; b[i])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; a.<span class="built_in">size</span>()) <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; w;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		tree[i].data = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> id1, num, id2;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		cin &gt;&gt; id1 &gt;&gt; num;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">			cin &gt;&gt; id2;</span><br><span class="line">			tree[id1].child.<span class="built_in">push_back</span>(id2);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp.<span class="built_in">push_back</span>(tree[<span class="number">0</span>].data);</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; ans[i].<span class="built_in">size</span>()<span class="number">-1</span>; j++) &#123;</span><br><span class="line">			cout &lt;&lt; ans[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans[i][ans[i].<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1079-Total-Sales-of-Supply-Chain"><a href="#1079-Total-Sales-of-Supply-Chain" class="headerlink" title="1079 Total Sales of Supply Chain"></a>1079 Total Sales of Supply Chain</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> P, r;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; chain[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> project[<span class="number">100010</span>];</span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> root,<span class="type">double</span> price)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (chain[root].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		ans += price * project[root];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chain[root].<span class="built_in">size</span>(); i++ ) &#123;</span><br><span class="line">		<span class="built_in">DFS</span>(chain[root][i], (<span class="number">1</span> + r * <span class="number">0.01</span>) * price);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; P &gt;&gt; r;</span><br><span class="line">	<span class="built_in">fill</span>(project, project + <span class="number">100010</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> num, temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			project[i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			chain[i].<span class="built_in">push_back</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">0</span>, P);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1f\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1090-Highest-Price-in-Supply-Chain"><a href="#1090-Highest-Price-in-Supply-Chain" class="headerlink" title="1090 Highest Price in Supply Chain"></a>1090 Highest Price in Supply Chain</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> P, r;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; chain[<span class="number">100010</span>];</span><br><span class="line"><span class="type">double</span> maxprice = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> root, <span class="type">double</span> price)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (chain[root].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;price&quot;</span> &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (price &gt; maxprice) &#123;</span><br><span class="line">			maxprice = price;</span><br><span class="line">			maxnum = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (price == maxprice) &#123;</span><br><span class="line">			maxnum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chain[root].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="built_in">DFS</span>(chain[root][i], (<span class="number">1</span> + r * <span class="number">0.01</span>) * price);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; P &gt;&gt; r;</span><br><span class="line">	<span class="type">int</span> temp, root = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; temp;</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">-1</span>) &#123;</span><br><span class="line">			root = i;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		chain[temp].<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(root, P);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2f %d\n&quot;</span>, maxprice, maxnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1106-Lowest-Price-in-Supply-Chain"><a href="#1106-Lowest-Price-in-Supply-Chain" class="headerlink" title="1106 Lowest Price in Supply Chain"></a>1106 Lowest Price in Supply Chain</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">double</span> P, r;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; chain[<span class="number">500010</span>];</span><br><span class="line"><span class="type">int</span> minnum = <span class="number">0</span>, minlayer = <span class="number">500010</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> root,<span class="type">int</span> layer)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (chain[root].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (layer &lt; minlayer) &#123;</span><br><span class="line">			minlayer = layer;</span><br><span class="line">			minnum = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (layer == minlayer) &#123;</span><br><span class="line">			minnum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; chain[root].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">		<span class="built_in">DFS</span>(chain[root][i], layer + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; P &gt;&gt; r;</span><br><span class="line">	<span class="type">int</span> num, temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		<span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			chain[i].<span class="built_in">push_back</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">DFS</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">double</span> price = <span class="built_in">pow</span>((<span class="number">1</span> + r * <span class="number">0.01</span>), minlayer)  * P;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.4f %d\n&quot;</span>, price, minnum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1004-Counting-Leaves"><a href="#1004-Counting-Leaves" class="headerlink" title="1004 Counting Leaves"></a>1004 Counting Leaves</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N, M;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> layer = <span class="number">0</span>;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line">node chain[<span class="number">110</span>];</span><br><span class="line">queue&lt;node&gt;q;</span><br><span class="line"><span class="type">int</span> number[<span class="number">110</span>], level = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (level &lt; top.layer)</span><br><span class="line">			level = top.layer;</span><br><span class="line">		<span class="keyword">if</span> (top.child.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">			number[top.layer]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; top.child.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">			chain[top.child[i]].layer = top.layer + <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(chain[top.child[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">	<span class="type">int</span> id, num, temp;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">		cin &gt;&gt; id &gt;&gt; num;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			chain[id].child.<span class="built_in">push_back</span>(temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	q.<span class="built_in">push</span>(chain[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">BFS</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= level - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; number[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; number[level] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1086-Tree-Traversals-Again-中序-x3D-gt-后序"><a href="#1086-Tree-Traversals-Again-中序-x3D-gt-后序" class="headerlink" title="1086 Tree Traversals Again  中序&#x3D;&gt;后序"></a>1086 Tree Traversals Again  中序&#x3D;&gt;后序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; postorder;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	node* rchild = <span class="literal">NULL</span>, * lchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line">stack&lt;node*&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">post</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">post</span>(root-&gt;rchild);</span><br><span class="line">	postorder.<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; temp;</span><br><span class="line">	node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">	root-&gt;data = temp;</span><br><span class="line">	node* top = root;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//true:往左插入孩子，false：右</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">&quot;Pop&quot;</span>) &#123;</span><br><span class="line">			top = q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">&quot;Push&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">				top-&gt;lchild = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">				top = top-&gt;lchild;</span><br><span class="line">				top-&gt;data = temp;</span><br><span class="line">				q.<span class="built_in">push</span>(top);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				top-&gt;rchild = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">				top = top-&gt;rchild;</span><br><span class="line">				top-&gt;data = temp;</span><br><span class="line">				q.<span class="built_in">push</span>(top);</span><br><span class="line">			&#125;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">post</span>(root);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; postorder.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; postorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序+中序=&gt;后序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N, pre[<span class="number">31</span>], in[<span class="number">31</span>], post[<span class="number">31</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	node* lchild = <span class="literal">NULL</span>;</span><br><span class="line">	node* rchild = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> inL, <span class="type">int</span> inR)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (preL + <span class="number">1</span> &gt; preR) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">	root-&gt;data = pre[preL];</span><br><span class="line">	<span class="type">int</span> i = inL;</span><br><span class="line">	<span class="keyword">for</span> (; i &lt; inR; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (pre[preL] == in[i])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	root-&gt;lchild = <span class="built_in">create</span>(preL + <span class="number">1</span>, preL + i - inL + <span class="number">1</span>, inL, i);</span><br><span class="line">	root-&gt;rchild = <span class="built_in">create</span>(preL + i - inL + <span class="number">1</span>, preR, i + <span class="number">1</span>, inR);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">postorder</span>(root-&gt;lchild);</span><br><span class="line">	<span class="built_in">postorder</span>(root-&gt;rchild);</span><br><span class="line">	post[n++] = root-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="type">int</span> temp, innum = <span class="number">0</span>, prenum = <span class="number">0</span>;</span><br><span class="line">	stack&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="keyword">if</span> (s==<span class="string">&quot;Push&quot;</span>) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			q.<span class="built_in">push</span>(temp);</span><br><span class="line">			pre[prenum++] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="string">&quot;Pop&quot;</span>) &#123;</span><br><span class="line">			in[innum++] = q.<span class="built_in">top</span>();</span><br><span class="line">			q.<span class="built_in">pop</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	node* root = <span class="built_in">create</span>(<span class="number">0</span>, N, <span class="number">0</span>, N);</span><br><span class="line">	<span class="built_in">postorder</span>(root);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; post[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; post[N - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1102-Invert-a-Binary-Tree-输出层序、中序"><a href="#1102-Invert-a-Binary-Tree-输出层序、中序" class="headerlink" title="1102 Invert a Binary Tree  输出层序、中序"></a>1102 Invert a Binary Tree  输出层序、中序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> rchild = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> lchild = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> flag[<span class="number">10</span>];</span><br><span class="line">node tree[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;layer;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;in;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">layerorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">		layer.<span class="built_in">push_back</span>(top);</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (tree[top].lchild!=<span class="number">-1</span>) &#123;</span><br><span class="line">			q.<span class="built_in">push</span>(tree[top].lchild);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tree[top].rchild!=<span class="number">-1</span>) &#123;</span><br><span class="line">			q.<span class="built_in">push</span>(tree[top].rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tree[root].lchild != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">inorder</span>(tree[root].lchild);</span><br><span class="line">	&#125;</span><br><span class="line">	in.<span class="built_in">push_back</span>(root);</span><br><span class="line">	<span class="keyword">if</span> (tree[root].rchild != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">inorder</span>(tree[root].rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fill</span>(flag, flag + <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="type">char</span> l, r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; r &gt;&gt; l;</span><br><span class="line">		<span class="keyword">if</span> (r &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; r &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			tree[i].rchild = r - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			flag[r - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; l &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">			tree[i].lchild = l - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			flag[l - <span class="string">&#x27;0&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!flag[i]) &#123;</span><br><span class="line">			root = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">layerorder</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; layer[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; layer[N - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">inorder</span>(root);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; in[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; in[N - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1043-Is-It-a-Binary-Search-Tree"><a href="#1043-Is-It-a-Binary-Search-Tree" class="headerlink" title="1043 Is It a Binary Search Tree"></a>1043 Is It a Binary Search Tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,num[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	node* left = <span class="literal">NULL</span>, * right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">		root-&gt;data = n;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; root-&gt;data) &#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;left, n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;right, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;preorder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	preorder.<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line">	<span class="built_in">pre</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">pre</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;repreorder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">repre</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	repreorder.<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line">	<span class="built_in">repre</span>(root-&gt;right);</span><br><span class="line">	<span class="built_in">repre</span>(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;postorder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">post</span>(root-&gt;left);</span><br><span class="line">	<span class="built_in">post</span>(root-&gt;right);</span><br><span class="line">	postorder.<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;repostorder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">repost</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">repost</span>(root-&gt;right);</span><br><span class="line">	<span class="built_in">repost</span>(root-&gt;left);</span><br><span class="line">	repostorder.<span class="built_in">push_back</span>(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (num[i] != n[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N ; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">		<span class="built_in">insert</span>(root, num[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">pre</span>(root);</span><br><span class="line">	<span class="built_in">repre</span>(root);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">judge</span>(preorder)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">post</span>(root);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; postorder.<span class="built_in">size</span>()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			cout &lt;&lt; postorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt; postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">judge</span>(repreorder)) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="built_in">repost</span>(root);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; repostorder.<span class="built_in">size</span>()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			cout &lt;&lt; repostorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; repostorder[repostorder.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1064-Complete-Binary-Search-Tree"><a href="#1064-Complete-Binary-Search-Tree" class="headerlink" title="1064 Complete Binary Search Tree"></a>1064 Complete Binary Search Tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N,num[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	node* right = <span class="literal">NULL</span>;</span><br><span class="line">	node* left = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node*&gt;q;</span><br><span class="line"><span class="function">node* <span class="title">CBT</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (left + <span class="number">1</span> == right) &#123;</span><br><span class="line">		node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">		root-&gt;data = num[left];</span><br><span class="line">		<span class="comment">//cout &lt;&lt; num[left] &lt;&lt; endl;</span></span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> n = right - left;<span class="comment">//该树共n个结点</span></span><br><span class="line">	<span class="type">int</span> k = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) ;<span class="comment">//前k层是满的</span></span><br><span class="line">	<span class="type">int</span> k_num = <span class="built_in">pow</span>(<span class="number">2</span>, k) - <span class="number">1</span>;<span class="comment">// 前k层有k_num个结点</span></span><br><span class="line">	<span class="type">int</span> last_num = n - k_num;<span class="comment">//最后一层结点个数</span></span><br><span class="line">	<span class="type">int</span> last_left = (last_num - (<span class="type">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, k - <span class="number">1</span>)))&gt;=<span class="number">0</span>?(<span class="type">int</span>)(<span class="built_in">pow</span>(<span class="number">2</span>, k - <span class="number">1</span>)): last_num;</span><br><span class="line">	<span class="type">int</span> root_index = (k_num - <span class="number">1</span>) / <span class="number">2</span> + last_left + left;</span><br><span class="line">	node* root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">	<span class="comment">//cout &lt;&lt; num[root_index] &lt;&lt; endl;</span></span><br><span class="line">	root-&gt;data = num[root_index];</span><br><span class="line">	root-&gt;left = <span class="built_in">CBT</span>(left, root_index);</span><br><span class="line">	root-&gt;right = <span class="built_in">CBT</span>(root_index + <span class="number">1</span>, right);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;layerorder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">layer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node* top = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		layerorder.<span class="built_in">push_back</span>(top-&gt;data);</span><br><span class="line">		<span class="keyword">if</span> (top-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			q.<span class="built_in">push</span>(top-&gt;left);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (top-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">			q.<span class="built_in">push</span>(top-&gt;right);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(num, num + N,cmp);</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	root = <span class="built_in">CBT</span>(<span class="number">0</span>, N);</span><br><span class="line">	q.<span class="built_in">push</span>(root);</span><br><span class="line">	<span class="built_in">layer</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		cout &lt;&lt; layerorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; layerorder[N - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> N, num[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cbt[<span class="number">1010</span>], index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root &gt; N) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">inorder</span>(root * <span class="number">2</span>);</span><br><span class="line">	cbt[root] = num[index++];</span><br><span class="line">	<span class="built_in">inorder</span>(root * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(num, num + N, cmp);</span><br><span class="line">	<span class="comment">//num是结果的中序遍历</span></span><br><span class="line">	<span class="built_in">inorder</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cout &lt;&lt; cbt[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; cbt[N] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1099-Build-A-Binary-Search-Tree"><a href="#1099-Build-A-Binary-Search-Tree" class="headerlink" title="1099 Build A Binary Search Tree"></a>1099 Build A Binary Search Tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> N,num[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> left = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">node tree[maxn];</span><br><span class="line"><span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> BST[maxn];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (number &gt; N) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (tree[root].left != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">inorder</span>(tree[root].left);</span><br><span class="line">	&#125;</span><br><span class="line">	BST[root] = num[number++];</span><br><span class="line">	<span class="keyword">if</span> (tree[root].right != <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">inorder</span>(tree[root].right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; layerorder;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">layer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> top = q.<span class="built_in">front</span>();</span><br><span class="line">		layerorder.<span class="built_in">push_back</span>(BST[top]);</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (tree[top].left != <span class="number">-1</span>)</span><br><span class="line">			q.<span class="built_in">push</span>(tree[top].left);</span><br><span class="line">		<span class="keyword">if</span> (tree[top].right != <span class="number">-1</span>)</span><br><span class="line">			q.<span class="built_in">push</span>(tree[top].right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; tree[i].left &gt;&gt; tree[i].right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(num, num + N, cmp);</span><br><span class="line">	<span class="built_in">inorder</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">layer</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">		cout &lt;&lt; layerorder[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	cout &lt;&lt; layerorder[N - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1066-Root-of-AVL-Tree"><a href="#1066-Root-of-AVL-Tree" class="headerlink" title="1066 Root of AVL Tree"></a>1066 Root of AVL Tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="type">int</span> height = <span class="number">1</span>;</span><br><span class="line">	node* left = <span class="literal">NULL</span>, * right = <span class="literal">NULL</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">balance</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">get</span>(root-&gt;left) - <span class="built_in">get</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(node* root)</span> </span>&#123;</span><br><span class="line">	root-&gt;height = <span class="built_in">max</span>(<span class="built_in">get</span>(root-&gt;left), <span class="built_in">get</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;left;</span><br><span class="line">	root-&gt;left = temp-&gt;right;</span><br><span class="line">	temp-&gt;right = root;</span><br><span class="line">	<span class="built_in">update</span>(root);</span><br><span class="line">	<span class="built_in">update</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">L</span><span class="params">(node*&amp; root)</span> </span>&#123;</span><br><span class="line">	node* temp = root-&gt;right;</span><br><span class="line">	root-&gt;right = temp-&gt;left;</span><br><span class="line">	temp-&gt;left = root;</span><br><span class="line">	<span class="built_in">update</span>(root);</span><br><span class="line">	<span class="built_in">update</span>(temp);</span><br><span class="line">	root = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(node*&amp; root, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		root = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">		root-&gt;data = num;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (num &lt; root-&gt;data) &#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;left, num);</span><br><span class="line">		<span class="built_in">update</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">balance</span>(root) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">balance</span>(root-&gt;left) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">R</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">L</span>(root-&gt;left);</span><br><span class="line">				<span class="built_in">R</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">insert</span>(root-&gt;right, num);</span><br><span class="line">		<span class="built_in">update</span>(root);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">balance</span>(root) &lt;= <span class="number">-2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">balance</span>(root-&gt;right) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">R</span>(root-&gt;right);</span><br><span class="line">				<span class="built_in">L</span>(root);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	node* root = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; temp;</span><br><span class="line">		<span class="built_in">insert</span>(root, temp);</span><br><span class="line">		<span class="comment">//cout &lt;&lt; root-&gt;data &lt;&lt; endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; root-&gt;data &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1107-Social-Clusters"><a href="#1107-Social-Clusters" class="headerlink" title="1107 Social Clusters"></a>1107 Social Clusters</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line"><span class="type">int</span> f[maxn];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;hobby;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> a = x;</span><br><span class="line">	<span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">		x = f[x];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> faA = <span class="built_in">findfather</span>(a);</span><br><span class="line">	<span class="type">int</span> faB = <span class="built_in">findfather</span>(b);</span><br><span class="line">	<span class="keyword">if</span> (faA != faB) &#123;</span><br><span class="line">		f[faA] = f[faB];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> temp, course[maxn] = &#123; <span class="number">0</span> &#125;, root[maxn] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	string num;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">atoi</span>((num.<span class="built_in">substr</span>(<span class="number">0</span>, num.<span class="built_in">size</span>() - <span class="number">1</span>)).<span class="built_in">c_str</span>()); j++) &#123;</span><br><span class="line">			cin &gt;&gt; temp;</span><br><span class="line">			<span class="keyword">if</span> (course[temp] == <span class="number">0</span>)</span><br><span class="line">				course[temp] = i;</span><br><span class="line">			<span class="built_in">Union</span>(i, <span class="built_in">findfather</span>(course[temp]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl &lt;&lt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		root[<span class="built_in">findfather</span>(i)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root[i] != <span class="number">0</span>)</span><br><span class="line">			cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">	<span class="built_in">sort</span>(root, root + maxn, cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, root[i]);</span><br><span class="line">		<span class="keyword">if</span> (i != cnt<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1098-Insertion-or-Heap-Sort"><a href="#1098-Insertion-or-Heap-Sort" class="headerlink" title="1098 Insertion or Heap Sort"></a>1098 Insertion or Heap Sort</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> N, num[maxn], iter[maxn];</span><br><span class="line"><span class="type">bool</span> insert = <span class="literal">false</span>, heap = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downAdjust</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> change = <span class="number">2</span> * low;</span><br><span class="line">	<span class="keyword">while</span> (change &lt;= high) &#123;</span><br><span class="line">		<span class="keyword">if</span> (change + <span class="number">1</span> &lt; high &amp;&amp; iter[change] &lt; iter[change + <span class="number">1</span>]) &#123;</span><br><span class="line">			change++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (iter[low] &lt; iter[change]) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(iter[low], iter[change]);</span><br><span class="line">			low = change;</span><br><span class="line">			change = low * <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">		cin &gt;&gt; iter[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//判断</span></span><br><span class="line">	<span class="type">int</span> index = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (index &lt;= N &amp;&amp; iter[index] &gt;= iter[index - <span class="number">1</span>]) &#123;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> p = index;</span><br><span class="line">	<span class="keyword">while</span> (p &lt;= N &amp;&amp; num[p] == iter[p]) p++;</span><br><span class="line">	<span class="keyword">if</span> (p == N + <span class="number">1</span>) insert = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> heap = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (insert) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Insertion Sort\n&quot;</span>;</span><br><span class="line">		<span class="built_in">sort</span>(iter + <span class="number">1</span>, iter + index + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">			cout &lt;&lt; iter[i];</span><br><span class="line">			<span class="keyword">if</span> (i != N) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (heap) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Heap Sort\n&quot;</span>;</span><br><span class="line">		<span class="type">int</span> high = N;</span><br><span class="line">		<span class="keyword">for</span> (; high &gt; <span class="number">1</span>; high--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (iter[high] &lt; iter[<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(iter[<span class="number">1</span>], iter[high]);</span><br><span class="line">		<span class="built_in">downAdjust</span>(<span class="number">1</span>, high - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">			cout &lt;&lt; iter[i];</span><br><span class="line">			<span class="keyword">if</span> (i != N) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
